<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CONSTELLATION by Junkyard.AI</title>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg: #050505;
            --fg: #00ff00; /* Oscilloscope Green */
            --dim: #004400;
            --alert: #ff0000;
            --warn: #ffcc00;
            --font: 'JetBrains Mono', monospace;
        }

        body { 
            margin: 0; overflow: hidden; 
            background-color: var(--bg); 
            font-family: var(--font); 
            color: var(--fg);
            user-select: none;
            transition: background-color 0.3s;
        }
        
        canvas { display: block; }

        /* --- UI GRID --- */
        #ui-grid {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: grid;
            grid-template-columns: 280px 1fr 280px;
            grid-template-rows: 60px 1fr 140px; 
            padding: 20px; box-sizing: border-box;
            z-index: 10;
            transition: opacity 0.5s ease;
        }

        /* Presentation Mode Hides UI */
        body.presentation-mode #ui-grid { opacity: 0; pointer-events: none; }
        body.presentation-mode .branding { opacity: 0; }
        
        /* Hint for exiting presentation mode */
        #presentation-hint {
            position: absolute; top: 20px; width: 100%; text-align: center;
            opacity: 0; pointer-events: none; transition: opacity 0.5s;
            z-index: 100; text-shadow: 0 0 5px #000;
            font-size: 10px; letter-spacing: 2px;
        }
        body.presentation-mode #presentation-hint { opacity: 0.5; }

        /* METERS */
        .meter-container {
            border: 1px solid var(--dim);
            background: rgba(0, 10, 0, 0.9);
            padding: 15px;
            display: flex; flex-direction: column; gap: 8px;
            pointer-events: auto;
            backdrop-filter: blur(2px);
        }

        .label { font-size: 10px; color: var(--fg); opacity: 0.7; text-transform: uppercase; letter-spacing: 1px; }
        .value { font-size: 14px; font-weight: 700; margin-bottom: 2px; }
        
        /* Bar Meters */
        .bar-bg { width: 100%; height: 6px; background: var(--dim); position: relative; overflow: hidden; }
        .bar-fill { height: 100%; background: var(--fg); width: 0%; transition: width 0.05s linear; }

        /* Clipping Indicator */
        .clip-indicator {
            width: 10px; height: 10px; background: #330000;
            border: 1px solid #550000;
            margin-left: auto;
            transition: background 0.1s;
        }
        .clip-indicator.active { background: #ff0000; box-shadow: 0 0 5px #ff0000; border-color: #ff0000; }
        .meter-row { display: flex; align-items: center; justify-content: space-between; }

        /* Correlation Meter */
        .corr-scale { 
            display: flex; justify-content: space-between; 
            font-size: 8px; opacity: 0.5; margin-top: 4px;
        }
        .corr-marker {
            width: 2px; height: 100%; background: #fff; position: absolute; left: 50%; top: 0;
            transform: translateX(-50%); z-index: 2;
        }

        /* Spectrum */
        #spectrum-container {
            grid-column: 1 / 4;
            grid-row: 3;
            display: flex;
            align-items: flex-end;
            justify-content: center;
            pointer-events: none;
            opacity: 0.8;
            position: relative;
        }
        #spectrum-canvas {
            width: 100%;
            height: 100%;
        }

        /* TRANSPORT CONTROLS */
        #transport-panel {
            grid-column: 2;
            grid-row: 2;
            align-self: end;
            margin-bottom: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-end;
            pointer-events: auto;
            opacity: 0; /* Hidden until active */
            transition: opacity 0.5s;
        }
        #transport-panel.active { opacity: 1; }

        .scrub-container {
            width: 100%;
            max-width: 600px;
            display: flex; flex-direction: column; gap: 5px;
        }
        .scrub-bar {
            width: 100%; height: 20px;
            background: rgba(0, 20, 0, 0.5);
            border: 1px solid var(--dim);
            position: relative;
            cursor: crosshair;
            display: flex; align-items: center;
        }
        .scrub-bar:hover { border-color: var(--fg); }
        .scrub-fill {
            height: 100%; background: var(--dim);
            width: 0%; pointer-events: none;
        }
        .scrub-head {
            width: 2px; height: 100%; background: var(--fg);
            position: absolute; left: 0%; pointer-events: none;
            box-shadow: 0 0 10px var(--fg);
        }
        .time-display {
            display: flex; justify-content: space-between;
            font-size: 10px; color: var(--fg);
        }

        /* Color Picker */
        .theme-selector {
            display: flex; gap: 5px; margin-top: 10px;
        }
        .color-dot {
            width: 15px; height: 15px; border-radius: 50%; cursor: pointer;
            border: 1px solid rgba(255,255,255,0.2);
        }
        .color-dot:hover { transform: scale(1.1); }

        /* DROP ZONE */
        #drop-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            z-index: 50; pointer-events: auto; cursor: pointer;
            backdrop-filter: blur(5px);
            opacity: 1; transition: opacity 0.3s;
        }
        #drop-overlay.hidden { opacity: 0; pointer-events: none; }
        
        .drop-box {
            border: 2px solid var(--fg); padding: 50px;
            text-align: center; background: rgba(0, 20, 0, 0.5);
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        .drop-box:hover { background: rgba(0, 40, 0, 0.6); }

        /* EXPORT CONTROLS */
        #export-panel {
            grid-column: 3; grid-row: 2;
            align-self: end; justify-self: end;
            display: flex; flex-direction: column; gap: 5px;
            margin-bottom: 20px;
            opacity: 0; pointer-events: none;
            transition: opacity 0.3s;
        }
        #export-panel.visible {
            opacity: 1; pointer-events: auto;
        }

        /* RECENTS PANEL */
        #recents-container {
            margin-top: 20px;
            padding-top: 10px;
            border-top: 1px solid var(--dim);
            display: none; /* Hidden until data exists */
        }
        .recent-item {
            font-size: 10px;
            padding: 6px 0;
            color: var(--fg);
            opacity: 0.6;
            cursor: pointer;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            transition: opacity 0.2s, padding 0.2s;
        }
        .recent-item:hover {
            opacity: 1;
            padding-left: 5px;
            background: rgba(0, 50, 0, 0.3);
        }
        .session-hint {
            font-size: 8px;
            opacity: 0.4;
            margin-top: 10px;
            font-style: italic;
        }

        /* MEMORY TRACKER */
        #memory-tracker {
            margin-top: 10px;
            font-size: 8px;
            color: var(--fg);
            opacity: 0.8;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .mem-bar-bg {
            width: 100px; height: 4px; background: var(--dim);
            position: relative; overflow: hidden;
        }
        .mem-bar-fill {
            height: 100%; background: var(--fg); width: 0%;
            transition: width 0.3s, background-color 0.3s;
        }

        /* UTILS */
        .mono-font { font-family: 'JetBrains Mono', monospace; }
        button {
            background: rgba(0,0,0,0.3); border: 1px solid var(--fg); color: var(--fg);
            padding: 8px 12px; font-family: var(--font); font-size: 10px;
            cursor: pointer; text-transform: uppercase; margin-top: 5px;
            transition: all 0.2s;
        }
        button:hover { background: var(--fg); color: var(--bg); }
        button:active { transform: translateY(1px); }
        
        .panel-right {
            grid-column: 3; grid-row: 1 / 3;
            text-align: right;
            align-items: flex-end;
        }

        .branding {
            position: absolute; bottom: 20px; right: 20px;
            text-align: right; pointer-events: none;
            z-index: 5;
            transition: opacity 0.5s;
        }
        .branding h1 { margin: 0; font-size: 16px; font-weight: 700; letter-spacing: 2px; }
        .branding h2 { margin: 0; font-size: 10px; opacity: 0.6; font-weight: 400; }

        /* BUTTON GROUPS */
        .btn-group { display: flex; gap: 5px; }
        .btn-group button { flex: 1; }

    </style>
    <!-- THREE.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <!-- BRANDING -->
    <div class="branding">
        <h1>CONSTELLATION</h1>
        <h2>by Junkyard.AI</h2>
    </div>

    <!-- PRESENTATION HINT -->
    <div id="presentation-hint">PRESS ESC TO EXIT PRESENTATION MODE</div>

    <!-- UI LAYER -->
    <div id="ui-grid">
        <!-- TOP LEFT: METRICS -->
        <div class="meter-container" style="grid-column: 1; grid-row: 1 / 3; overflow-y: auto;">
            <div style="margin-bottom: 10px; border-bottom: 1px solid var(--dim); padding-bottom: 5px;">
                <div class="label" style="font-size: 12px; color: var(--fg);">CONSTELLATION</div>
                <div class="label">SIGNAL TERMINAL</div>
            </div>
            
            <div class="meter-row">
                <div>
                    <div class="label">RMS LEVEL</div>
                    <div class="value" id="val-db">-inf dB</div>
                </div>
                <div style="text-align: right;">
                    <div class="label">CLIP</div>
                    <div id="clip-led" class="clip-indicator"></div>
                </div>
            </div>
            
            <div class="label" style="margin-top: 10px;">L Channel</div>
            <div class="bar-bg"><div id="bar-l" class="bar-fill"></div></div>
            
            <div class="label" style="margin-top: 5px;">R Channel</div>
            <div class="bar-bg"><div id="bar-r" class="bar-fill"></div></div>

            <div style="margin-top: 20px; border-top: 1px solid var(--dim); padding-top: 10px;">
                <div class="label">PHASE CORRELATION</div>
                <div class="value" id="val-corr">+1.00</div>
                <div class="bar-bg" style="height: 10px;">
                    <div class="corr-marker" id="corr-marker"></div>
                    <div style="position: absolute; left: 50%; height: 100%; width: 1px; background: #555;"></div>
                </div>
                <div class="corr-scale"><span>-1</span><span>0</span><span>+1</span></div>
            </div>

            <div style="margin-top: 20px; border-top: 1px solid var(--dim); padding-top: 10px;">
                <div class="label">STEREO WIDTH</div>
                <div class="value" id="val-width">0%</div>
            </div>
            
            <div style="margin-top: 20px; display: flex; flex-direction: column; gap: 5px;">
                <button id="btn-pause" onclick="togglePause()">PAUSE / RESUME</button>
                <button id="btn-mic" id="btn-mic" onclick="toggleMic()">ACTIVATE MIC</button>
                <button id="btn-load" onclick="showLoader()">LOAD FILE</button>
            </div>

            <!-- RECENTS PANEL & MEMORY -->
            <div id="recents-container">
                <div class="label">SESSION HISTORY</div>
                <div id="recents-list">
                    <!-- Items injected here -->
                </div>
                
                <div class="label" style="margin-top: 15px;">SESSION RAM</div>
                <div id="memory-tracker">
                    <span id="mem-text">0 MB</span>
                    <div class="mem-bar-bg"><div id="mem-bar" class="mem-bar-fill"></div></div>
                </div>
                <div class="session-hint" style="margin-top: 5px;">CLEARS ON REFRESH</div>
            </div>
        </div>

        <!-- CENTER: TRANSPORT -->
        <div id="transport-panel">
            <div class="scrub-container">
                <div class="time-display">
                    <span id="time-current">00:00.00</span>
                    <span id="track-name" style="opacity:0.5; max-width: 200px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">NO SIGNAL</span>
                    <span id="time-total">00:00.00</span>
                </div>
                <div class="scrub-bar" id="scrub-bar">
                    <div class="scrub-fill" id="scrub-fill"></div>
                    <div class="scrub-head" id="scrub-head"></div>
                </div>
            </div>
        </div>

        <!-- EXPORT PANEL (Bottom Right, visible on pause) -->
        <div id="export-panel" class="meter-container">
            <div class="label">CAPTURE SNAPSHOT</div>
            <div style="font-size:9px; opacity:0.6; margin-bottom:5px;">PAUSE TO ENABLE</div>
            <div class="btn-group">
                <button onclick="exportSnapshot(1080, 1080, false)">SQUARE</button>
                <button onclick="exportSnapshot(1080, 1920, false)">STORY</button>
            </div>
            <div class="label" style="margin-top:10px;">TRANSPARENT (PNG)</div>
            <div class="btn-group">
                <button onclick="exportSnapshot(1080, 1080, true)">SQUARE</button>
                <button onclick="exportSnapshot(1080, 1920, true)">STORY</button>
            </div>
        </div>

        <!-- TOP RIGHT: SETTINGS -->
        <div class="meter-container panel-right">
            <div class="label">VISUAL CONFIGURATION</div>
            <div style="margin-top: 10px; width: 100%;">
                <div class="label">THEME COLOR</div>
                <div class="theme-selector">
                    <div class="color-dot" style="background: #00ff00;" onclick="setTheme('#00ff00', '#004400')"></div> <!-- Green -->
                    <div class="color-dot" style="background: #00ffff;" onclick="setTheme('#00ffff', '#004444')"></div> <!-- Cyan -->
                    <div class="color-dot" style="background: #ff0000;" onclick="setTheme('#ff0000', '#440000')"></div> <!-- Red -->
                    <div class="color-dot" style="background: #bf00ff;" onclick="setTheme('#bf00ff', '#2a0044')"></div> <!-- Purple -->
                    <div class="color-dot" style="background: #ff00ff;" onclick="setTheme('#ff00ff', '#440044')"></div> <!-- Pink -->
                </div>
            </div>
            
            <button style="margin-top: 20px; width: 100%;" onclick="togglePresentation()">PRESENTATION MODE</button>

            <div style="margin-top: 20px; text-align: right; opacity: 0.5; font-size: 10px;">
                <div class="label">GONIOMETER MODE</div>
                <div>X = SIDE (L-R)</div>
                <div>Y = MID (L+R)</div>
            </div>
        </div>

        <!-- BOTTOM: SPECTRUM -->
        <div id="spectrum-container">
            <canvas id="spectrum-canvas"></canvas>
        </div>
    </div>

    <!-- DRAG DROP -->
    <div id="drop-overlay" onclick="document.getElementById('file-input').click()">
        <div class="drop-box">
            <div style="font-size: 20px; font-weight: 700;">CONSTELLATION</div>
            <div style="font-size: 12px; margin-top: 10px; opacity: 0.7;">CLICK OR DRAG AUDIO FILE</div>
            <div style="font-size: 10px; margin-top: 20px; color: var(--fg); opacity: 0.5;">by Junkyard.AI</div>
        </div>
        <input type="file" id="file-input" accept="audio/*" style="display:none;">
    </div>

    <!-- Hidden Audio Element for Streaming/Seeking -->
    <audio id="audio-element" loop crossorigin="anonymous"></audio>

    <script type="module">
        import * as THREE from 'three';

        // --- CONFIG ---
        const SAMPLES = 4096; 
        const SAFE_MEM_LIMIT_MB = 250; // Conservative limit for session files
        
        // --- GLOBALS ---
        let scene, camera, renderer;
        let scopeGeometry, scopePoints, scopeMaterial;
        let audioContext, sourceNode, micStream;
        let analyserL, analyserR, analyserSpectrum;
        let dataL, dataR;
        let freqData;
        let isRunning = false;
        let isMic = false;
        
        // Player Globals
        const audioElement = document.getElementById('audio-element');
        let isSeeking = false;
        
        // History Globals
        let currentFileObj = null;
        let sessionHistory = [];

        // Spectrum Canvas
        const specCanvas = document.getElementById('spectrum-canvas');
        const specCtx = specCanvas.getContext('2d');

        // Theme Globals
        let currentFG = '#00ff00';
        let currentDim = '#004400';

        // --- EXPORTED FUNCTIONS ---

        window.togglePause = function() {
            if(!audioContext) return;
            const exportPanel = document.getElementById('export-panel');
            
            if (isMic) {
                if(audioContext.state === 'running') {
                    audioContext.suspend();
                    setPauseState(true);
                } else {
                    audioContext.resume();
                    setPauseState(false);
                }
            } else {
                if (audioElement.paused) {
                    audioElement.play();
                    setPauseState(false);
                } else {
                    audioElement.pause();
                    setPauseState(true);
                }
            }
        };

        window.toggleMic = function() {
            if(isMic) {
                // Deactivate Mic
                if(micStream) {
                    micStream.getTracks().forEach(track => track.stop());
                    micStream = null;
                }
                isMic = false;
                
                // Reset UI
                const btnMic = document.getElementById('btn-mic');
                btnMic.innerText = "ACTIVATE MIC";
                btnMic.style.background = "";
                btnMic.style.color = "";
                
                // Attempt to return to file playback
                if(audioElement.src && currentFileObj) {
                    document.getElementById('track-name').innerText = "RESUMING FILE...";
                    
                    // Resume context if it was suspended during mic usage
                    if (audioContext.state === 'suspended') audioContext.resume();

                    // Re-init audio chain for file
                    if (audioElement._sourceNode) {
                        setupNodes(audioElement._sourceNode, false);
                        audioElement.play().catch(e => console.error(e));
                    }
                    
                    document.getElementById('track-name').innerText = currentFileObj.name.toUpperCase();
                } else {
                    // No file loaded, reset to empty state
                    document.getElementById('track-name').innerText = "NO SIGNAL";
                    document.getElementById('transport-panel').classList.remove('active');
                    showLoader();
                }
                
            } else {
                activateMic();
            }
        }

        window.showLoader = function() {
            document.getElementById('drop-overlay').classList.remove('hidden');
        }

        window.togglePresentation = function() {
            document.body.classList.toggle('presentation-mode');
        }

        // Add ESC key listener for Presentation Mode
        window.addEventListener('keydown', (e) => {
            if(e.key === "Escape") {
                document.body.classList.remove('presentation-mode');
            }
        });

        window.exportSnapshot = function(width, height, transparent) {
            if (!renderer) return;

            const originalSize = new THREE.Vector2();
            renderer.getSize(originalSize);
            
            renderer.setSize(width, height);
            
            const aspect = width / height;
            const frustum = 2; 
            camera.left = -frustum * aspect;
            camera.right = frustum * aspect;
            camera.top = frustum;
            camera.bottom = -frustum;
            camera.updateProjectionMatrix();

            // Handle Transparency
            const oldClearColor = renderer.getClearColor(new THREE.Color());
            const oldClearAlpha = renderer.getClearAlpha();
            const oldBg = scene.background;

            if (transparent) {
                scene.background = null; 
                renderer.setClearColor(0x000000, 0); 
            }

            renderer.render(scene, camera);
            const dataURL = renderer.domElement.toDataURL('image/png');
            
            // Restore
            if (transparent) {
                scene.background = oldBg;
                renderer.setClearColor(oldClearColor, oldClearAlpha);
            }

            const link = document.createElement('a');
            link.download = `CONSTELLATION_${transparent ? 'ALPHA_' : ''}${width}x${height}_${Date.now()}.png`;
            link.href = dataURL;
            link.click();

            renderer.setSize(originalSize.width, originalSize.height);
            onResize(); 
            renderer.render(scene, camera); 
        }

        window.setTheme = function(fg, dim) {
            currentFG = fg;
            currentDim = dim;
            document.documentElement.style.setProperty('--fg', fg);
            document.documentElement.style.setProperty('--dim', dim);
            if(scopeMaterial) scopeMaterial.color.set(fg);
            if(audioElement.paused && isRunning) renderer.render(scene, camera);
        }

        // --- INTERNAL FUNCTIONS ---

        function setPauseState(paused) {
            const exportPanel = document.getElementById('export-panel');
            const btn = document.getElementById('btn-pause');
            
            if (paused) {
                btn.style.background = 'var(--fg)';
                btn.style.color = 'var(--bg)';
                btn.innerText = "RESUME";
                exportPanel.classList.add('visible');
            } else {
                btn.style.background = '';
                btn.style.color = 'var(--fg)';
                btn.innerText = "PAUSE";
                exportPanel.classList.remove('visible');
            }
        }

        initGraphics();
        setupInteraction();
        animate();

        function initGraphics() {
            const container = document.createElement('div');
            document.body.appendChild(container);

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050505);

            const aspect = window.innerWidth / window.innerHeight;
            const frustumSize = 2;
            camera = new THREE.OrthographicCamera(
                -frustumSize * aspect, frustumSize * aspect, 
                frustumSize, -frustumSize, 
                0.1, 100
            );
            camera.position.z = 10;

            renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            const positions = new Float32Array(SAMPLES * 3);
            scopeGeometry = new THREE.BufferGeometry();
            scopeGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

            scopeMaterial = new THREE.PointsMaterial({
                color: currentFG,
                size: 2,
                sizeAttenuation: false,
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending
            });

            scopePoints = new THREE.Points(scopeGeometry, scopeMaterial);
            scene.add(scopePoints);

            const gridHelper = new THREE.GridHelper(4, 4, 0x111111, 0x111111);
            gridHelper.rotation.x = Math.PI / 2;
            scene.add(gridHelper);
            
            window.addEventListener('resize', onResize);
            onResize();
        }

        function initAudio() {
            if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
            if (audioContext.state === 'suspended') audioContext.resume();
        }

        function setupNodes(source, isMicrophone = false) {
            if(sourceNode && sourceNode !== source) {
                try { sourceNode.disconnect(); } catch(e){}
            }
            
            sourceNode = source;
            isMic = isMicrophone;

            const splitter = audioContext.createChannelSplitter(2);
            analyserL = audioContext.createAnalyser();
            analyserR = audioContext.createAnalyser();
            analyserSpectrum = audioContext.createAnalyser();

            analyserL.fftSize = SAMPLES * 2;
            analyserR.fftSize = SAMPLES * 2;
            analyserSpectrum.fftSize = 2048; 
            analyserSpectrum.smoothingTimeConstant = 0.85;

            source.connect(splitter);
            splitter.connect(analyserL, 0);
            splitter.connect(analyserR, 1);
            source.connect(analyserSpectrum); 
            
            if (!isMicrophone) {
                // Ensure we don't double connect if reusing element source
                try { source.connect(audioContext.destination); } catch(e) {}
                document.getElementById('transport-panel').classList.add('active');
            } else {
                document.getElementById('transport-panel').classList.remove('active');
            }

            dataL = new Float32Array(SAMPLES);
            dataR = new Float32Array(SAMPLES);
            freqData = new Uint8Array(analyserSpectrum.frequencyBinCount);
            
            isRunning = true;
            document.getElementById('drop-overlay').classList.add('hidden');
            setPauseState(false);
        }

        function calculateMemory() {
            let totalBytes = 0;
            if (currentFileObj) totalBytes += currentFileObj.size;
            sessionHistory.forEach(f => totalBytes += f.size);
            
            const mb = (totalBytes / (1024 * 1024)).toFixed(1);
            const pct = Math.min(100, (totalBytes / (SAFE_MEM_LIMIT_MB * 1024 * 1024)) * 100);
            
            document.getElementById('mem-text').innerText = `${mb} MB`;
            const bar = document.getElementById('mem-bar');
            bar.style.width = `${pct}%`;
            
            // Color Coding
            if(pct > 90) bar.style.backgroundColor = "var(--alert)";
            else if(pct > 60) bar.style.backgroundColor = "var(--warn)";
            else bar.style.backgroundColor = "var(--fg)";
        }

        function updateHistoryUI() {
            const container = document.getElementById('recents-container');
            const list = document.getElementById('recents-list');
            list.innerHTML = "";

            if (sessionHistory.length === 0 && !currentFileObj) {
                container.style.display = "none";
                return;
            }

            container.style.display = "block";
            
            sessionHistory.forEach(file => {
                const el = document.createElement('div');
                el.className = 'recent-item';
                el.innerText = "> " + file.name.toUpperCase();
                el.onclick = () => handleFile(file);
                list.appendChild(el);
            });
            
            calculateMemory();
        }

        function handleFile(file) {
            initAudio();
            
            // Manage History:
            // 1. If we have a current file, and it's not the one we are about to load, push it to history.
            if (currentFileObj && currentFileObj !== file) {
                // Prevent duplicates in history
                if (!sessionHistory.includes(currentFileObj)) {
                    sessionHistory.unshift(currentFileObj);
                }
            }
            
            // 2. If the file we are loading IS in history, remove it from history (move to top/current)
            if (sessionHistory.includes(file)) {
                sessionHistory = sessionHistory.filter(f => f !== file);
            }
            
            // Limit history size to 6 items
            if (sessionHistory.length > 6) sessionHistory.pop();
            
            currentFileObj = file;
            updateHistoryUI();

            // --- Regular Loading Logic ---
            
            // If mic is active, deactivate it first
            if(isMic && micStream) {
                micStream.getTracks().forEach(t => t.stop());
                micStream = null;
                isMic = false;
                const btnMic = document.getElementById('btn-mic');
                btnMic.innerText = "ACTIVATE MIC";
                btnMic.style.background = "";
                btnMic.style.color = "";
            }

            if (audioElement.src) URL.revokeObjectURL(audioElement.src);

            const url = URL.createObjectURL(file);
            audioElement.src = url;
            document.getElementById('track-name').innerText = file.name.toUpperCase();

            audioElement.onloadedmetadata = () => {
                document.getElementById('time-total').innerText = formatTime(audioElement.duration);
            };

            if (!audioElement._sourceNode) {
                 audioElement._sourceNode = audioContext.createMediaElementSource(audioElement);
            }
            
            setupNodes(audioElement._sourceNode, false);
            audioElement.play().catch(e => console.error("Play error:", e));
        }

        function activateMic() {
            initAudio();
            audioElement.pause(); 
            
            navigator.mediaDevices.getUserMedia({ audio: true }).then(stream => {
                micStream = stream; // Store for cleanup
                const src = audioContext.createMediaStreamSource(stream);
                setupNodes(src, true);
                
                // UI Update
                document.getElementById('track-name').innerText = "LIVE INPUT";
                const btnMic = document.getElementById('btn-mic');
                btnMic.innerText = "DEACTIVATE MIC";
                btnMic.style.background = "var(--alert)";
                btnMic.style.color = "#fff";
                
                document.getElementById('time-current').innerText = "--:--";
                document.getElementById('time-total').innerText = "--:--";
            }).catch(e => {
                alert("Microphone access denied or error.");
            });
        }

        function setupInteraction() {
            const drop = document.getElementById('drop-overlay');
            const fileIn = document.getElementById('file-input');
            const scrubBar = document.getElementById('scrub-bar');

            drop.addEventListener('dragover', e => { e.preventDefault(); drop.style.background = '#002200'; });
            drop.addEventListener('dragleave', e => { e.preventDefault(); drop.style.background = 'rgba(0,0,0,0.85)'; });
            drop.addEventListener('drop', e => {
                e.preventDefault();
                drop.style.background = 'rgba(0,0,0,0.85)';
                if (e.dataTransfer.files.length) handleFile(e.dataTransfer.files[0]);
            });
            fileIn.addEventListener('change', e => { if(e.target.files.length) handleFile(e.target.files[0]); });

            scrubBar.addEventListener('mousedown', e => {
                if(!audioElement.duration || isMic) return;
                isSeeking = true;
                seek(e);
            });
            window.addEventListener('mousemove', e => { if(isSeeking) seek(e); });
            window.addEventListener('mouseup', () => { isSeeking = false; });
        }

        function seek(e) {
            const scrubBar = document.getElementById('scrub-bar');
            const rect = scrubBar.getBoundingClientRect();
            let x = e.clientX - rect.left;
            x = Math.max(0, Math.min(x, rect.width));
            const pct = x / rect.width;
            
            document.getElementById('scrub-head').style.left = (pct * 100) + "%";
            document.getElementById('scrub-fill').style.width = (pct * 100) + "%";
            
            if (audioElement.duration) audioElement.currentTime = pct * audioElement.duration;
        }

        function formatTime(seconds) {
            if(!seconds || isNaN(seconds)) return "00:00.00";
            const m = Math.floor(seconds / 60);
            const s = Math.floor(seconds % 60);
            const ms = Math.floor((seconds % 1) * 100);
            return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}.${ms.toString().padStart(2, '0')}`;
        }

        function toDB(gain) { return 20 * Math.log10(Math.max(gain, 0.00001)); }

        function calculateMetrics(lData, rData) {
            let sumL = 0, sumR = 0;
            let sumLR = 0, sumL2 = 0, sumR2 = 0;
            let peakL = 0, peakR = 0;

            for(let i=0; i<lData.length; i++) {
                const l = lData[i];
                const r = rData[i];
                sumL += l * l; sumR += r * r; sumLR += l * r; sumL2 += l * l; sumR2 += r * r;
                if(Math.abs(l) > peakL) peakL = Math.abs(l);
                if(Math.abs(r) > peakR) peakR = Math.abs(r);
            }

            const rmsL = Math.sqrt(sumL / lData.length);
            const rmsR = Math.sqrt(sumR / rData.length);
            const rmsTotal = (rmsL + rmsR) / 2;
            const denom = Math.sqrt(sumL2 * sumR2);
            let correlation = denom > 0.00001 ? sumLR / denom : 0;
            return { rmsL, rmsR, rmsTotal, correlation: Math.max(-1, Math.min(1, correlation)), peakL, peakR };
        }

        function drawSpectrum() {
            if(!analyserSpectrum) return;
            const w = specCanvas.width;
            const h = specCanvas.height;
            specCtx.clearRect(0, 0, w, h);
            analyserSpectrum.getByteFrequencyData(freqData);
            
            specCtx.beginPath();
            specCtx.strokeStyle = currentFG;
            specCtx.lineWidth = 1;
            specCtx.fillStyle = currentDim;
            
            const sliceWidth = w * 1.0 / freqData.length;
            let x = 0;
            specCtx.moveTo(0, h);
            for(let i = 0; i < freqData.length; i++) {
                const v = freqData[i] / 255.0;
                const y = h - (v * h);
                specCtx.lineTo(x, y);
                x += sliceWidth;
            }
            specCtx.lineTo(w, h);
            specCtx.fill();
            specCtx.stroke();
            
            specCtx.fillStyle = currentFG;
            specCtx.font = "10px JetBrains Mono";
            specCtx.globalAlpha = 0.5;
            specCtx.fillText("20Hz", 10, h - 5);
            specCtx.fillText("20kHz", w - 40, h - 5);
            specCtx.globalAlpha = 1.0;
        }

        function animate() {
            requestAnimationFrame(animate);
            if (isRunning && analyserL && analyserR) {
                if (!isMic && !isSeeking && audioElement.duration) {
                    const pct = (audioElement.currentTime / audioElement.duration) * 100;
                    document.getElementById('scrub-head').style.left = pct + "%";
                    document.getElementById('scrub-fill').style.width = pct + "%";
                    document.getElementById('time-current').innerText = formatTime(audioElement.currentTime);
                }

                analyserL.getFloatTimeDomainData(dataL);
                analyserR.getFloatTimeDomainData(dataR);

                const positions = scopeGeometry.attributes.position.array;
                for (let i = 0; i < SAMPLES; i++) {
                    const l = dataL[i];
                    const r = dataR[i];
                    const x = (l - r) * 1.0; 
                    const y = (l + r) * 1.0; 
                    positions[i * 3] = x;
                    positions[i * 3 + 1] = y;
                    positions[i * 3 + 2] = 0;
                }
                scopeGeometry.attributes.position.needsUpdate = true;

                const m = calculateMetrics(dataL, dataR);
                document.getElementById('val-db').innerText = toDB(m.rmsTotal).toFixed(1) + " dB";
                
                const mapDB = (val) => Math.min(100, Math.max(0, (toDB(val) + 60) * (100/60)));
                document.getElementById('bar-l').style.width = mapDB(m.rmsL) + "%";
                document.getElementById('bar-r').style.width = mapDB(m.rmsR) + "%";

                const clipEl = document.getElementById('clip-led');
                if (m.peakL >= 0.99 || m.peakR >= 0.99) {
                    clipEl.classList.add('active'); 
                } else {
                    clipEl.classList.remove('active');
                }

                const corrPercent = ((m.correlation + 1) / 2) * 100;
                document.getElementById('corr-marker').style.left = corrPercent + "%";
                document.getElementById('val-corr').innerText = (m.correlation > 0 ? "+" : "") + m.correlation.toFixed(2);
                
                if (m.correlation < 0) {
                    document.getElementById('val-corr').style.color = 'var(--alert)';
                    document.getElementById('corr-marker').style.background = 'var(--alert)';
                } else {
                    document.getElementById('val-corr').style.color = 'var(--fg)';
                    document.getElementById('corr-marker').style.background = '#fff';
                }

                document.getElementById('val-width').innerText = Math.max(0, (1 - m.correlation) * 50).toFixed(0) + "%";
                drawSpectrum();
            }
            renderer.render(scene, camera);
        }

        function onResize() {
            const aspect = window.innerWidth / window.innerHeight;
            const frustum = 2;
            camera.left = -frustum * aspect; camera.right = frustum * aspect;
            camera.top = frustum; camera.bottom = -frustum;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            const container = document.getElementById('spectrum-container');
            if(container) {
                specCanvas.width = container.clientWidth;
                specCanvas.height = container.clientHeight;
            }
        }
    </script>
</body>
</html>
